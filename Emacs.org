#+TITLE: Emacs Configuration
#+AUTHOR: Dan Murphy
#+PROPERTY: header-args :tangle ~/.emacs.efs/init.el :mkdirp yes

* Introduction

This Org Mode document generates the Emacs configuration file [[file:init.el][init.el]].

#+begin_src emacs-lisp

  ;; NOTE: Do not edit this file directly: init.el is generated from Emacs.org.
  ;; Edit that file in Emacs and run org-bable-tangle (C-c C-v C-t) to update
  ;; init.el automatically.

#+end_src

* Package System Setup

Emacs has a built-in package manager (=package.el=), but [[https://github.com/raxod502/straight.el][straight.el]] is a more advanced alternative with a number of useful features. In particular, =straight.el= can install and update packages from their repositories, letting you add packages that aren't in ELPA or MELPA. 

Some  useful commands:
- =straight-pull-all= will upgrade all of your active packages once you restart Emacs.
- =straight-check-all= will upgrade all of your active packages while Emacs is running.
- =straight-remove-unused-repos= will delete unused repository folders. Note that if you just want to uninstall a package, you can simply remove the corresponding line from your configuration.

[[https://github.com/jwiegley/use-package][use-package]] makes configuration and loading of packages much easier. =straight.el= provides full =use-package= integration.

#+begin_src emacs-lisp

  ;; straight.el bootstrap script
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Install =use-package= with =straight.el=
  (straight-use-package 'use-package)

  ;; =use-package= forms invoke =straight.el= to install packages,
  ;; unless specified otherwise.
  ;; This is analogous to setting =use-package-always-ensure= with =package.el=
  (setq straight-use-package-by-default t)

#+end_src

* Keybindings

** Yay Evil!

[[https://github.com/emacs-evil/evil][Evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim, turning Emacs into a modal editor. [[https://github.com/emacs-evil/evil-collection][Evil Collection]] provides additional bindings for the parts of Emacs that Evil does not cover.

I want =C-u= to follow Vim's behaviour: scroll up by half a screen in normal state, delete back to indentation in insert state. By default, however, =C-u= is bound in Emacs to the =universal-argument= prefix, which you may want to rebind to something else.

Evil can use one of three undo systems:
  - =undo-fu=, in which case the [[https://gitlab.com/ideasman42/emacs-undo-fu][Undo Fu]] package must be installed;
  - =undo-tree=, in which case the [[https://www.dr-qubit.org/undo-tree.html][Undo Tree]] package must be installed and =undo-tree-mode= must be activated;
  - =undo-redo=, which uses commands natively available in Emacs 28.

#+begin_src emacs-lisp

  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; If you switch to undo-redo in Emacs 28, you can remove the following line
  (use-package undo-fu)

  (use-package evil
    :init
    (setq evil-want-integration t   ; required by evil-collection
          evil-want-keybinding nil  ; required by evil-collection
          evil-want-Y-yank-to-eol t
          evil-want-C-u-delete t
          evil-want-C-u-scroll t
          evil-undo-system 'undo-fu)  ; try undo-redo when Emacs 28 is released
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

#+end_src

Evil does not seem to include a direct analog of (Neo)Vim's "highlighted yank" feature. The [[https://github.com/edkolev/evil-goggles][evil-goggles]] package does this and more, adding visual hints for most Evil edit operations. However, if you only want the highlighted yank, you can follow the instructions in [[https://blog.meain.io/2020/emacs-highlight-yanked/][this blog post]] to write your own (surprisingly simple) function, which makes use of the built-in =pulse.el= .

#+begin_src emacs-lisp

  (setq pulse-delay 0.04)
  (setq pulse-iterations 10)

  (defun efs/evil-highlight-yank (orig-fn beg end &rest args)
    "Advice to be added to 'evil-yank' to highlight yanked region."
    (pulse-momentary-highlight-region beg end)
    (apply orig-fn beg end args))

  (advice-add 'evil-yank :around 'efs/evil-highlight-yank) 

#+end_src

** Evil Plugins

Any reasonably important/popular Vim plugin has probably been ported to Evil. For ideas, see the [[https://www.emacswiki.org/emacs/Evil#h5o-6][EmacsWiki entry]] on Evil, and the Doom Emacs [[https://github.com/hlissner/doom-emacs/tree/develop/modules/editor/evil#plugins][Evil module]]. You might also have a look at the emulated plugins for the [[https://github.com/VSCodeVim/Vim#-emulated-plugins][VS Code]] and [[https://github.com/JetBrains/ideavim/wiki/Emulated-plugins][IntelliJ]] Vim emulators.

[[https://github.com/emacs-evil/evil-surround][Evil Surround]] emulates Tim Pope's [[https://github.com/tpope/vim-surround][surround.vim]] plugin.

#+begin_src emacs-lisp

  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
  
#+end_src

** Display Available Bindings with Which-Key

[[https://github.com/justbur/emacs-which-key][which-key]] displays all available bindings when you enter an incomplete command (prefix keys). It lets you discover and use bindings without having to actively research and memorize them.

#+begin_src emacs-lisp

(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.5))

#+end_src

** Simplified Custom Bindings with General

[[https://github.com/noctuid/general.el][general]] provides a convenient, unified interface for defining keybindings; you can think of =general= as doing for bindings what =use-package= does for packages.

For instance, we can use =general= to escape to normal state (from insert or replace states) with 'jk'. (Alternatively, you could try the dedicated package [[https://github.com/syl20bnr/evil-escape][evil-escape]], used in Doom Emacs.)

=general= also makes it easy to set up Vim-style leader keys, and integrates beautifully with =which-key=. Used together, these two packages let you create your own Spacemacs-like binding system:
    - use =general= to define bindings that are intuitively organized under mnemonic prefixes (=b= for buffer, =f= for file, =g= for git, =w= for window, etc.);
    - =which-key='s real-time display of available bindings makes such multi-step bindings discoverable.

#+begin_src emacs-lisp

  (use-package general
    :config
    ;; From insert or replace states, exit to normal state with 'jk'
    (general-define-key
     :states '(insert replace)
     "j" (general-key-dispatch 'self-insert-command
           :timeout 0.25
           "k" 'evil-normal-state))
    ;; Set up leader key(s)
    (general-create-definer efs/leader-def
      :keymaps '(normal visual insert emacs)
      :prefix "SPC"
      :non-normal-prefix "C-SPC"))

#+end_src

** Spacemacs-Style (Leader-Based) Bindings

We have a good deal of flexibility as to where we actually define bindings:
    - We can define them all in once place; note that you can create a binding to a command before loading the package that provides that command.
    - We can define the bindings to built-in Emacs commands in one place, and keep other bindings with their packages. The advantage of this approach is that, if we decide to remove or disable a package, we don't have to track down its keybindings somewhere else.
   
#+begin_src emacs-lisp

  (efs/leader-def
    "SPC" '(execute-extended-command :which-key "Execute command")
    ;; Buffers
    "b"  '(:ignore t :which-key "Buffers")
    "bb" '(consult-buffer :which-key "Switch buffer")
    "bd" '(evil-delete-buffer :which-key "Delete buffer")
    "bk" '(kill-buffer :which-key "Kill buffer")
    "bn" '(evil-next-buffer :which-key "Next buffer")
    "bp" '(evil-prev-buffer :which-key "Previous buffer")
    ;; Files
    "f"  '(:ignore t :which-key "Files")
    "ff" '(find-file :which-key "Find file")
    "fr" '(consult-recent-file :which-key "Recent file")
    "fs" '(save-buffer :which-key "Save file")
    ;; Git
    "g"  '(:ignore t :which-key "Git")
    "gs" '(magit-status :which-key "magit status")
    ;; Project
    "p"  '(:ignore t :which-key "Project")
    "pc" '(projectile-compile-project :which-key "Compile project")
    "pf" '(projectile-find-file :which-key "Find file")
    "pk" '(projectile-kill-buffers :which-key "Kill all project buffers")
    "pp" '(projectile-switch-project :which-key "Switch project")
    "pr" '(projectile-recentf :which-key "Open recent file")
    ;; Search
    "s"  '(:ignore t :which-key "Search")
    "so" '(consult-imenu :which-key "consult-imenu")
    "ss" '(consult-line :which-key "consult-line")
    ;; Windows
    "w"  '(:ignore t :which-key "Windows")
    "wc" '(evil-window-delete :which-key "Close window")
    "wh" '(evil-window-left :which-key "Focus left")
    "wj" '(evil-window-down :which-key "Focus down")
    "wk" '(evil-window-up :which-key "Focus up")
    "wl" '(evil-window-right :which-key "Focus right")
    "wH" '(windmove-swap-states-left :which-key "Swap left")
    "wJ" '(windmove-swap-states-down :which-key "Swap down")
    "wK" '(windmove-swap-states-up :which-key "Swap up")
    "wL" '(windmove-swap-states-right :which-key "Swap right")
    "wo" '(delete-other-windows :which-key "Delete other windows")
    "ws" '(evil-window-split :which-key "Split horizontal")
    "wu" '(winner-undo :which-key "Undo")
    "wU" '(winner-redo :which-key "Redo")
    "wv" '(evil-window-vsplit :which-key "Split vertical")
    "ww" '(evil-window-next :which-key "Next window")
    "wW" '(evil-window-prev :which-key "Previous window"))

#+end_src

* Appearance and Interface

** Basic Interface Settings

Unnecesary visual elements have been disabled, but the menu bar can be helpful while you're learning Emacs, so you may wish to leave it enabled. Alternatively, you can toggle the use of the menu bar with =M-x menu-bar-mode=.

#+begin_src emacs-lisp

  ;; Set default dimensions for new frames
  (add-to-list 'default-frame-alist '(width . 101))
  (add-to-list 'default-frame-alist '(height . 51))

  ;; Disable startup screen
  (setq inhibit-startup-message t) 

  ;; Disable the menu bar, scroll bar, tool bar and tooltips
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)

  (set-fringe-mode 12)  ; Set left and right margins

  (global-visual-line-mode 1)  ; Visually wrap long lines

  (blink-cursor-mode 0)  ; Disable blinking cursor

  ;; Enable line numbers globally, then disable them for specific modes
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode t)

  (dolist (mode '(eshell-mode-hook
                  shell-mode-hook
                  term-mode-hook
                  vterm-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Fonts

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :font "Iosevka" :height 160)
  (set-face-attribute 'fixed-pitch nil :font "Iosevka" :height 160)
  (set-face-attribute 'variable-pitch nil :font "Lato" :height 160)

#+end_src

** Color Theme

[[https://github.com/hlissner/emacs-doom-themes][doom-themes]] is an excellent collection of high-quality themes with support for many different Emacs modes. Take a look at the [[https://github.com/hlissner/emacs-doom-themes/tree/screenshots][screenshots]] to find one you like. I'll also add the excellent [[https://www.nordtheme.com/ports/emacs][Nord theme]]. You can quickly switch between themes with =M-x load-theme=.

[[https://github.com/hlissner/emacs-solaire-mode][Solaire mode]] helps to visually distinguish "real" buffers (that is, the file-visiting code buffers where you do most of your work) from "unreal" buffers (popups, sidebars, log buffers, terminals, etc.) by giving the latter a slightly different (lighter or darker) background.

#+begin_src emacs-lisp

  (use-package doom-themes
    :init (load-theme 'doom-one t))

  (use-package nord-theme)

  (use-package solaire-mode
    :config (solaire-global-mode +1))

#+end_src

** Parenthesis Matching
   
Show Paren mode highlights matching delimiters. [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] makes it easier to visually match brackets and parentheses in code buffers.

#+begin_src emacs-lisp

  (show-paren-mode 1)

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** Indentation Guides

[[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]] adds visual guides for indentation levels. Toggle with =M-x highlight-indent-guides-mode= (you may want to set up a binding for this).

#+begin_src emacs-lisp

  (use-package highlight-indent-guides
    :hook (c-mode-common . highlight-indent-guides-mode)
    :config (setq highlight-indent-guides-method 'character
                  highlight-indent-guides-responsive 'nil))

#+end_src

** Mode Line

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is a very attractive mode-line configuration. The default configuration is quite good but you can check out the [[https://github.com/seagle0128/doom-modeline#customize][configuration options]] for more things you can enable or disable.

*NOTE:* The first time you load your configuration on a new machine, you'll need to run =M-x all-the-icons-install-fonts= so that mode-line icons display correctly.

#+begin_src emacs-lisp

  ;; Display column number in mode line
  (column-number-mode)

  (use-package all-the-icons)

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 40)
             (doom-modeline-indent-info t)))

  (set-face-attribute 'mode-line nil :font "Source Sans Pro" :height 160)
  (set-face-attribute 'mode-line-inactive nil :font "Source Sans Pro" :height 160)

#+end_src

** Completion System

Emacs includes several built-in completion packages (Ido and Icomplete), but many users prefer [[https://emacs-helm.github.io/helm/][Helm]] or [[https://github.com/abo-abo/swiper][Ivy]]. [[https://github.com/minad/vertico][Vertico]] and its complementary packages are designed around an alternative philosophy that I find very appealing:
- Vertico provides a  new completion UI but uses Emacs's built-in completion mechanics. This means a small code base, excellent performance, and automatic compatibility with other packages.
- Unlike the heavyweight, monolithic Helm and Ivy, the Vertico "ecosystem" consists of independent packages, each responsible for a specific element of the completion interface:
    - [[https://github.com/minad/vertico][Vertico]]: vertical completion UI.
    - [[https://github.com/minad/corfu][Corfu]]: the =completion-in-region= counterpart to Vertico.
    - [[https://github.com/minad/consult][Consult]]: useful search and navigation commands; analagous to Counsel and Swiper in Ivy.
    - [[https://github.com/minad/marginalia][Marginalia]]: annotations for minibuffer completions; analagous to Ivy Rich.
    - [[https://github.com/oantolin/orderless][Orderless]]: advanced completion style.
    - [[https://github.com/oantolin/embark][Embark]]: actions and context menu for the minibuffer.

To really understand what each of these components is doing, it's best to introduce them one at a time: see [[https://github.com/minad/vertico#complementary-packages][this approach]] suggested by the author of Vertico.

*** Completions with Vertico

Because Vertico uses Emacs's native completion system, we can use the built-in =savehist-mode= to preserve minibuffer history.

#+begin_src emacs-lisp

  (use-package savehist
    :config
    (setq history-length 16)
    :init
    (savehist-mode))

  ;; Taken from David Wilson's Emacs configuration
  (defun efs/minibuffer-backward-kill (arg)
    "When minibuffer is completing a file name delete up to parent
    folder, otherwise delete a word"
    (interactive "p")
    (if minibuffer-completing-file-name
        (if (string-match-p "/." (minibuffer-contents))
            (zap-up-to-char (- arg) ?/)
          (delete-minibuffer-contents))
      (delete-word (- arg))))

  (use-package vertico
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                :map minibuffer-local-map
                ("M-h" . efs/minibuffer-backward-kill))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))

#+end_src

*** Completions in Regions with Corfu

Corfu is the =completion-in-region= counterpart of the Vertico minibuffer UI and the Vertico-system equivalent of the [[https://company-mode.github.io/][Company]] package.

#+begin_src emacs-lisp

  (use-package corfu
  :bind (:map corfu-map
         ("C-j" . corfu-next)
         ("C-k" . corfu-previous))
  :custom
  (corfu-cycle t)
  :init
  (corfu-global-mode))
  
#+end_src

*** Enhanced Completion Commands with Consult

Consult provides a /lot/ of functions. Go through them and make a list or table of particularly useful ones. Set up (Spacemacs-style) bindings as desired.

There are also many [[https://github.com/minad/consult#recommended-packages][complementary packages]] to try. You'll almost certainly want =cape=, =consult-flycheck=, =consult-lsp=, =consult-projectile= and =consult-yasnippet=, and possibly also =consult-dir=, =consult-eglot= and =affe=. 

#+begin_src emacs-lisp

  ;; Required to narrow list to recent files in consult-buffer
  (recentf-mode 1)

  (use-package consult
    :demand t
    :bind ("C-s" . consult-line))

#+end_src

*** Completion Annotations with Marginalia

Cycle through available annotations (including none) with =marginalia-cycle=.

#+begin_src emacs-lisp

  (use-package marginalia
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle))
    :init
    (marginalia-mode))

#+end_src

*** Advanced Completion Candidate Filtering with Orderless

#+begin_src emacs-lisp

  (use-package orderless
    :custom (completion-styles '(orderless)))

#+end_src

*** Completion Actions with Embark

[[https://github.com/oantolin/embark][Embark]] is an extremely flexible and powerful package that provides a sort of "right-click" contextual menu, accessed through the =embark-act= command.

#+begin_src emacs-lisp

  (use-package embark
    :bind ("C-;" . embark-act)
    ("C-:" . embark-dwim)
    ("C-h B" . embark-bindings)) ;; alternative to =describe-bindings=

  (use-package embark-consult
    :after (embark)
    :demand t ;; only necessary if you have the hook below
    ;; The following hook adds Consult previews as you move around an
    ;; auto-updating embark-collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

#+end_src

Embark comes with [[https://github.com/oantolin/embark#showing-information-about-available-targets-and-actions][built-in indicators]] to display available actions and their keybindings. These indicators are perfectly good, but you may prefer to use which-key for a more consistent experience (the which-key display is also more compact). From the [[https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt][Embark wiki]]:

#+begin_src emacs-lisp

  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (setq embark-indicators
        '(embark-which-key-indicator
          embark-minimal-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)

#+end_src

** Window Management

*** Better Window Swapping with windmove

=windmove= is a built-in package that provides useful window-management commands. Evil makes most of these redundant, but Evil's commands for moving the current buffer to another window aren't very intuitive, so we'll use the =windmove= alternatives.

#+begin_src emacs-lisp

  (general-define-key
   :keymaps 'evil-window-map
   "H" 'windmove-swap-states-left
   "J" 'windmove-swap-states-down
   "K" 'windmove-swap-states-up
   "L" 'windmove-swap-states-right)

#+end_src

*** Window History with winner

=winner= is a built-in package that provides undo/redo history for windows. Note that this isn't just useful for fixing accidental changes: if you need to concentrate on a particular buffer, use =C-w o= to close all other windows, then use =winner-undo= to restore your previous layout.

#+begin_src emacs-lisp

  (winner-mode 1)
  (general-define-key
   :keymaps 'evil-window-map
   "u" 'winner-undo
   "U" 'winner-redo)

#+end_src

*** TODO Efficient Window Selection with winum

[[https://github.com/deb0ch/emacs-winum][winum]] numbers your windows in the modeline and lets you select windows by number. By default, =winum= assigns window =0= to the minibuffer; you can also assign specific windows (e.g., Calculator, Flycheck errors, NeoTree) to specific numbers.

/Note:/ In the leader-key assignments below, =:which-key t= hides the bindings in the which-key panel (I don't want them cluttering up my prefix guide).

[[https://github.com/abo-abo/ace-window][ace-window]] is an alternative package that lets you select windows using an Avy/Easymark idiom. This would be a little slower than =winum=, but might offer a more consistent experience if you also use Easymark.

#+begin_src emacs-lisp

  (efs/leader-def
    "0" '(winum-select-window-0 :which-key t)
    "1" '(winum-select-window-1 :which-key t)
    "2" '(winum-select-window-2 :which-key t)
    "3" '(winum-select-window-3 :which-key t)
    "4" '(winum-select-window-4 :which-key t)
    "5" '(winum-select-window-5 :which-key t)
    "6" '(winum-select-window-6 :which-key t)
    "7" '(winum-select-window-7 :which-key t)
    "8" '(winum-select-window-8 :which-key t)
    "9" '(winum-select-window-9 :which-key t))

  (use-package winum
    :config
    (winum-mode))

#+end_src

** Help System

[[https://github.com/Wilfred/helpful][Helpful]] adds a lot of very helpful (get it?) information to Emacs' =describe-= command buffers.  For example, if you use =describe-function=, you will not only get the documentation about the function, you will also see the source code of the function and where it gets used in other places in the Emacs configuration.  It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp

  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :bind
    ([remap describe-command] . helpful-command)
    ([remap describe-function] . helpful-function)
    ([remap describe-key] . helpful-key)
    ([remap describe-symbol] . helpful-symbol)  ; try helpful-at-point?
    ([remap describe-variable] . helpful-variable))

#+end_src

* Basic Editing Settings

Don't make backup files.
Default to an indentation of 2 spaces, and use spaces instead of tabs (a.k.a. 'soft' tabs).

#+begin_src emacs-lisp

  (setq make-backup-files nil)

  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  (setq-default indent-tabs-mode nil)

#+end_src

Electric Pair mode is analagous to the Autopair package for Vim.

#+begin_src emacs-lisp

  (electric-pair-mode 1)

  ;; Disable <> auto-pairing
  (setq electric-pair-inhibit-predicate
    `(lambda (c)
      (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))

#+end_src

* Dired

Dired is Emacs's excellent file manager. With the [[https://github.com/crocket/dired-single][dired-single]] package, Emacs will reuse existing Dired buffers instead of spawning new ones.

[[https://github.com/jtbm37/all-the-icons-dired][all-the-icons-dired]] adds Dired support to all-the-icons. If you use Treemacs, an alternative is [[https://github.com/Alexander-Miller/treemacs#treemacs-icons-dired][treemacs-icons-dired]].

#+begin_src emacs-lisp

  (use-package dired
    :straight nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom ((dired-listing-switches "-agho --group-directories-first"))
    :config
    (setq delete-by-moving-to-trash t)
    (define-key dired-mode-map [remap dired-find-file]
      'dired-single-buffer)
    (define-key dired-mode-map [remap dired-mouse-find-file-other-window]
      'dired-single-buffer-mouse)
    (define-key dired-mode-map [remap dired-up-directory]
      'dired-single-up-directory)
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))

  (use-package dired-single
    :commands (dired dired-jump))

  ;;(use-package all-the-icons-dired
  ;;  :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open
    :commands (dired dired-jump)
    :config
    ;; The following line doesn't work as expected:
    ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("pdf" . "okular")
                                  ("png" . "gwenview")
                                  ("mkv" . "vlc"))))

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))

#+end_src

* Shells & Terminals

** vterm

[[https://github.com/akermu/emacs-libvterm/][vterm]] is a terminal emulator for Emacs based on [[https://github.com/neovim/libvterm][libvterm]], a C library developped by the Neovim project. Compared to term and ansi-term (Emacs's built-in terminal emulators), vterm provides much better performance, as well as superior compatibility with terminal applications.

Before installing vterm, make sure your system has the required packages installed. On an Arch-based system, these are =cmake=, =libtool= and (optionally) =libvterm=. Also, be sure to read the [[https://github.com/akermu/emacs-libvterm/#shell-side-configuration][Shell-side configuration]] and [[https://github.com/akermu/emacs-libvterm/#directory-tracking-and-prompt-tracking][Directory tracking and Prompt tracking]] sections of the vterm README: you need to add the =vterm_printf= and =vterm_prompt_end= functions to your shell's configuration file (=.bashrc= or =.zshrc=).

#+begin_src emacs-lisp

  (use-package vterm
    :commands vterm
    :config
    (setq vterm-shell "zsh")
    (setq vterm-max-scrollback 1000))

#+end_src

** eshell

/TODO./ eshell is a Bash-like shell written in elisp. Though slower than vterm and lacking some features of bash and zsh, it offers superior Emacs integration and a consistent experience across all OSes.

* Version Control

** Magit

[[https://magit.vc/][Magit]] is an outstanding Git interface for Emacs. [[https://github.com/magit/forge][Forge]] allows you to work with Git forges, such as GitHub and GitLab, from the comfort of Magit and the rest of Emacs.

#+begin_src emacs-lisp

  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; NOTE: Make sure to configure a GitHub token before using this package!
  ;; - https://magit.vc/manual/forge/Token-Creation.html#Token-Creation
  ;; - https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started
  ; (use-package forge
  ;   :after magit)

#+end_src

** Git Gutter

[[https://github.com/emacsorphanage/git-gutter][git-gutter]] highlights uncommited changes in the margin of the window. [[https://github.com/emacsorphanage/git-gutter-fringe][git-gutter-fringe]] is a variation of git-gutter that uses the fringe rather than the margin. Keep in mind that the fringe only appears in graphical Emacs buffers, so you cannot use git-gutter-fringe in the terminal. An alternative package is [[https://github.com/dgutov/diff-hl][diff-hl]].

Note that both git-gutter-fringe and diff-hl will conflict with other modes that put indicators in the fringe, notably [[https://www.flycheck.org/][Flycheck]]. A [[https://github.com/emacsorphanage/git-gutter-fringe/issues/9#issuecomment-611712558][good solution]] (used in [[https://github.com/hlissner/doom-emacs/blob/cdaa55b4dbfebe6c81ab92af6a7c9bc20f68f3a6/modules/ui/vc-gutter/config.el#L119][Doom Emacs]]) is to give the left fringe to your VCS and the right to Flycheck (or vice-versa).

#+begin_src emacs-lisp

  (use-package git-gutter
    :straight git-gutter-fringe
    :diminish
    :hook ((text-mode . git-gutter-mode)
           (prog-mode . git-gutter-mode))
    :config
    (setq git-gutter:update-interval 1)
    ;; Sadly, it seems that the following setting does not apply to git-gutter-fringe
    ;;(setq git-gutter:visual-line t)
    (require 'git-gutter-fringe)
    ;; Taken from Doom Emacs
    (define-fringe-bitmap 'git-gutter-fr:added [224]
      nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224]
      nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240]
      nil nil 'bottom))

#+end_src

* Org Mode

** Font Settings

The =efs/org-font-setup= function adjusts the sizes of headings and uses variable-width fonts in most cases so that it looks more like we're editing a document. We switch back to fixed width (monospace) fonts for code blocks and tables so that they display correctly.

#+begin_src emacs-lisp

  (defun efs/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.6)
                    (org-level-2 . 1.4)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Lato" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-document-info-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))

#+end_src
   
** Basic Confguration

This section contains the basic configuration for Org mode. I'm leaving a lot out for now, including the configuration for Org agendas and capture templates. When you're ready, watch the videos for [[https://youtu.be/VcgjTEa0kU4][Part 5]] and [[https://youtu.be/PNE-mgkZ6HM][Part 6]] and revisit.

#+begin_src emacs-lisp

  (defun efs/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    (setq org-list-indent-offset 2)
    (setq evil-auto-indent nil))

  (use-package org
    :hook (org-mode . efs/org-mode-setup)
    :config
    (setq org-ellipsis " ▸"
          org-hide-emphasis-markers t)
    (efs/org-font-setup))

#+end_src

** Toggle Markup Visibility

[[https://github.com/awth13/org-appear][org-appear]] is an invaluable package that makes it much easier to edit Org documents when =org-hide-emphasis-markers= is active. It temporarily makes concealed markup elements appear when the cursor enters an element. By default, toggling is instaneous and applies only to emphasis markers, but additional functionality can be enabled via custom variables.

#+begin_src emacs-lisp

  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    ;; :custom
    ;; (org-appear-autolinks t)  ;; toggle links
    ;; (org-appear-delay 0.5)    ;; delay before toggling
  )

#+end_src

** Heading Bullets

[[https://github.com/sabof/org-bullets][org-bullets]] replaces the heading stars in Org-mode buffers with nicer-looking characters that you can customize.  Another option for this is [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]].

#+begin_src emacs-lisp

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))

#+end_src

** Block Templates

These let you type things like =<el= and then hit =Tab= to expand the template.
See [[https://orgmode.org/manual/Structure-Templates.html][Structure Templates]] in the Org Mode manual, and [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][Babel Languages]] for supported languages and their identifiers.

#+begin_src emacs-lisp

  ;; Required as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("cpp" . "src cpp"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("go" . "src go"))
  (add-to-list 'org-structure-template-alist '("json" . "src json"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
  (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))

#+end_src

* Development

** Project Management with Projectile

[[https://projectile.mx/][Projectile]] is a project-interaction library, providing a number of features for easy project management and navigation. To get the most out of it, make sure you have =fd= and =ripgrep= installed on your system. You might also wish to install the [[https://github.com/dajva/rg.el][rg.el]] package.

All Projectile commands are available under the =projectile-command-map= prefix (bound to =C-c p=).

As an alternative to Projectile, =project.el= is a relatively new built-in package that might be worth trying at some point.

#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; Set this to the folder where you keep your Git repos
    (when (file-directory-p "~/Development")
      (setq projectile-project-search-path '("~/Development")))
    (setq projectile-switch-project-action #'projectile-dired))

#+end_src

** IDE Features with LSP Mode

[[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] is a Language Server Protocol client that provides optional integration with a number of popular Emacs packages, including consult, flycheck, projectile, treemacs and which-key. The [[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] package contains all the higher-level UI modules for =lsp-mode=.

All =lsp-mode= commands are available under the =lsp-keymap-prefix= (set to =C-c l=).

*** TODO Add header breadcrumb
*** TODO Add LSP information in modeline (if not enabled by default)

As an alternative to =lsp-mode=, you may wish to try [[https://github.com/joaotavora/eglot][Eglot]], a more minimalistic LSP-client. And you may want to supplement any LSP client with [[https://emacs-tree-sitter.github.io/][tree-sitter]] for enhanced syntax highlighting.

#+begin_src emacs-lisp

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :init
    (setq lsp-keymap-prefix "C-c l")
    :config
    (lsp-enable-which-key-integration t))

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode))

#+end_src

** TODO Syntax Checking with Flycheck

[[https://www.flycheck.org/en/latest/index.html][Flycheck]] is an on-the-fly syntax-checking extension, intended as a replacement for the older, built-in Flymake.

Since both Flycheck and =git-gutter-fringe= use the fringe area, we'll set Flycheck to use the right fringe; alternatively, you could try the left margin.

#+begin_src emacs-lisp

  (use-package flycheck
    :hook (prog-mode . flycheck-mode)
    :config
    (setq flycheck-indication-mode 'right-fringe))

#+end_src

** Snippets with YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system that lets you type an abbreviation that will then be automatically expanded into a function template. YASnippet does not include any snippets; these are collected in a separate package, [[https://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets]].

#+begin_src emacs-lisp

  (use-package yasnippet
    :hook (prog-mode . yas-minor-mode)
    :config
    (yas-reload-all))

  (use-package yasnippet-snippets)
  ;;(use-package yasnippet-snippets
  ;;  :after (yasnippet))

#+end_src

** Languages

*** C/C++

/Maximum line length:  80/
/Indentation: 2 spaces/

[[https://www.gnu.org/software/emacs/manual/html_node/ccmode/index.html][CC Mode]] is a built-in Emacs mode for editing C, C++, Java, and several other languages.

#+begin_src emacs-lisp

  (defun tusk/c-mode-common-setup ()
    (setq c-default-style "java"
          c-basic-offset 2
          indent-tabs-mode nil)
    (setq display-fill-column-indicator-column 79)
    (display-fill-column-indicator-mode 1))

  (add-hook 'c-mode-hook 'tusk/c-mode-common-setup)
  (add-hook 'c++-mode-hook 'tusk/c-mode-common-setup)

#+end_src

*** Java

/Maximum line length:  100/
/Indentation: 4 spaces/

#+begin_src emacs-lisp

  (defun tusk/java-mode-setup ()
    (setq c-default-style "java"
          c-basic-offset 4
          indent-tabs-mode nil)
    (setq display-fill-column-indicator-column 99)
    (display-fill-column-indicator-mode 1))

  (add-hook 'java-mode-hook 'tusk/java-mode-setup)

#+end_src

*** Markdown

You can toogle markup hiding with =C-c C-x C-m=.

#+begin_src emacs-lisp

  (defun efs/markdown-font-setup ()
    (variable-pitch-mode 1)
    (dolist (face '((markdown-header-face-1 . 2.0)
                    (markdown-header-face-2 . 1.7)
                    (markdown-header-face-3 . 1.4)
                    (markdown-header-face-4 . 1.1)
                    (markdown-header-face-5 . 1.0)
                    (markdown-header-face-6 . 1.0)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch appears that way
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch)
    (set-face-attribute 'markdown-inline-code-face nil :inherit 'fixed-pitch))

  (use-package markdown-mode
    ;; :hook ((markdown-mode . variable-pitch-mode)
    ;;        (markdown-mode . efs/markdown-font-setup))
    :config
    ;; (setq-default markdown-header-scaling t)
    (setq-default markdown-list-indent-width 2
                  markdown-footnote-location 'immediately
                  markdown-hide-urls t
                  markdown-hide-markup nil))

#+end_src
